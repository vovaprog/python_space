[Введение]

[Инструменты]

======================[Описание работы]===========================

=====================[Получение данных]===========================
Сначала нужно получить данные для отображения. Информация о космических объектах хранится в каталогах.
В каталог объекты собирают, как правило, по типу (звезды, шаровые скопления, галактики).
Есть каталоги, которые составляют по результатам исследования конкретной области космоса (например, "Молодые звезды в туманности Ориона"),
есть каталоги, составленные по результатам астрономических обзоров наземными и космическими телескопами,
и есть каталоги, где собраны данные по какому-то типу объектов из разных каталогов.
Нам для отображения нужны будут как раз такие каталоги, так в них можно найти наиболее полные списки объектов.
Одна из самых больших баз каталогов в интернете - это <a href="https://ru.wikipedia.org/wiki/VizieR">Центр астрономических данных в Страсбурге.</a>
Получить данные через интернет может любой желающий. Сервис для поиска и отображения данных называется
<a href="http://vizier.u-strasbg.fr/viz-bin/VizieR">VizieR</a>.
Для поиска каталогов можно ввести тип объекта, например, для поиска шаровых скоплений в строке поиска можно ввести "globular cluster".
Программа выдаст список каталогов по шаровым скоплениям (как правило, очень длинный) из которого можно выбрать каталог с нужными данными.
У каждого каталога есть идентификатор (напр. VII/202). Если выбрать каталог в длинном списке сложно, то можно попробовать
поискать каталог в google а потом вводить в VizieR найденный идентификатор каталога.
На странице каталога в VizieR доступно много операций с данными. Можно выбрать выводимые колонки, сортировку, количество выводимых строк,
задать фильтр по любым колонкам. В левой части страницы в блоке Preferences можно задать формат вывода.
По умолчанию стоит формат HTML Table, который выведет таблицу с данными на экран. А для загрузки в программу есть много более удобных для машины форматов.
Для загрузки в python я сохранял данные как "| - Separated-Values".  При выборе этого формата получаем файл, в котором строки таблицы
разделены переносом строки, а колонки - символом "|". В полученном файле перед набором строк с данными идет заголовок,
в котором описано из какого каталога были получены данные, примененные фильтры и т.п. Очень удобно - потом открыв файл сразу видно, что это за данные.

======================[Загрузка данных]===========================
Данные из интернета получили, теперь нужно загрузить их в программу.
Для работы с данными в Python есть отличная библиотека
<a href="https://ru.wikipedia.org/wiki/NumPy">NumPy</a> (<a href="http://www.numpy.org/">сайт</a>)
Она содержит много функций для работы с массивами данных. В частности, для загрузки данных из текстового файла есть две функции:
<a href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.loadtxt.html">loadtxt</a>
<a href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.genfromtxt.html">genfromtxt</a>
Они очень похожи. Отличаются тем, что в genfromtxt добавлена обработка отсутствующих в колонках значений.
Пример вызова функции loadtxt:
<pre>
data = np.loadtxt('data/globular_clusters.tsv', skiprows=49, delimiter='|', usecols=(1, 4, 5, 6, 7),
                  dtype=[('messier', 'int'), ('dist', 'float'), ('x', 'float'), ('y', 'float'), ('z', 'float')],
                  converters={1: convert_messier})
</pre>
Параметр <b>skiprows</b> позволяет пропустить заданное количество строк. В файлах полученных через VizieR в начале идет заголовок.
Смотрим сколько в нем строк и передаем в этом параметре.
Параметр <b>delimeter</b> - символ разделитель. В нашем случае - "|".
<b>usecols</b> - индексы колонок (начиная с 0), которые нужно загрузить из файла.
<b>dtype</b> - типы данных и названия колонок.
converters - функции преобразования данных. Во многих случаях значение из колонки текстового файла перед загрузкой нужно преобразовать.
Например, в файле название объекта в каталоге
<a href="https://ru.wikipedia.org/wiki/%D0%9A%D0%B0%D1%82%D0%B0%D0%BB%D0%BE%D0%B3_%D0%9C%D0%B5%D1%81%D1%81%D1%8C%D0%B5"><Мессье</a>
может быть записано как "M13" или "M 13" или "M   13". Если мы будем сравнивать
это значение с данными из другого источника нам проще иметь просто целочисленное значение. Для этого нам нужно написать функцию,
которая на вход получает строку - данные ячейки из файла, а возвращает число - индекс в каталоге Мессье.
Например, эта функция может выглядеть так:
<pre>
import re

def convert_messier(messier_string):
    match = re.search('M\\s+([0-9]+)', messier_string)
    if match is not None:
        return int(match.group(1))
    else:
        return 0
</pre>
re - <a href="https://docs.python.org/2/library/re.html">модуль Python</a> для работы с
<a href="https://ru.wikipedia.org/wiki/%D0%A0%D0%B5%D0%B3%D1%83%D0%BB%D1%8F%D1%80%D0%BD%D1%8B%D0%B5_%D0%B2%D1%8B%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F">регулярными выражениями</a>
Если функция преобразования совсем короткая, то удобно использовать lambda функцию - написать код преобразования прямо в вызове функции loadtxt.
Например:
<pre>
converters = {0: convert_messier, 2: lambda s: str(s).strip()}
</pre>
Функция преобразования для второй колонки убирает лишние пробелы по краям входной строки.

====================[Объединение таблиц]==========================

Часто бывает, что таблица каталога содержит не все нужные данные и нам нужно собрать данные из разных
каталогов или разных таблиц одного каталога. Например, таблица содержит координаты объектов, а названия объектов хранятся в другой таблице.
Нам нужно произвести аналог операции <a href="https://ru.wikipedia.org/wiki/Join_%28SQL%29">JOIN</a> из SQL.
Если для получения данных мы используем VizieR, то объединение таблиц можно произвести прямо в нем и получить готовую таблицу.
Для этого после открытия каталога нужно отметить галочками нужные таблицы и нажать кнопку "Join Selected Tables".
Если данные получены из разных источников, то их можно объединить в программе. Для этого в объединяемых таблицах должно быть
поле - идентификатор, по которому можно сопоставить строки таблиц. В роли такого идентификатора может выступать
название объекта в каком-нибудь известном каталоге. Например, для галактик и туманностей это может быть номер объекта
в каталоге <a href="https://ru.wikipedia.org/wiki/%D0%9D%D0%BE%D0%B2%D1%8B%D0%B9_%D0%BE%D0%B1%D1%89%D0%B8%D0%B9_%D0%BA%D0%B0%D1%82%D0%B0%D0%BB%D0%BE%D0%B3">NGC</a>,
для звезд - номер объекта в каталоге
<a href="https://ru.wikipedia.org/wiki/%D0%9A%D0%B0%D1%82%D0%B0%D0%BB%D0%BE%D0%B3_%D0%93%D0%B5%D0%BD%D1%80%D0%B8_%D0%94%D1%80%D0%B5%D0%B9%D0%BF%D0%B5%D1%80%D0%B0">Генри Дрейпера</a>.
Для объединения таблиц в Python будем использовать функцию join_by из модуля numpy.lib.recfunctions.
Перед вызовом функции нужно сначала подготовить данные. Согласно
<a href="http://pyopengl.sourceforge.net/pydoc/numpy.lib.recfunctions.html">описанию</a>
функции, массивы не должны содержать записей с одинаковыми значениями в поле, по которому мы объединяем таблицы.
То есть сначала нужно удалить записи с повторяющимися значениями в ключевом поле. Для этого используем функцию numpy.unique:
<pre>
result, indexes = np.unique(data['ngc'], return_index=True)
</pre>
Первым параметром передаем функции поле, в котором должны быть уникальные (не повторяющиеся) значения. Параметр <b>return_index = True</b>
говорит функции, что нужно вернуть индексы уникальных элементов во втором возвращаемом значении. Дальше нам нужно из исходного массива выбрать
элементы с индексами, которые вернула функция unique.
Делается это в numpy очень просто. Никаких циклов, всего одна строчка кода:
<pre>
data = data[indexes]
</pre>
В интернете есть описание проблем с функцией join_by, если исходные данные не отсортированы
по ключу, по которому выполняется объединение. Если join выполняется верно,
этот шаг можно пропустить. Отсортируем наши данные:
<pre>
dt = np.sort(dt, order=['ngc'])
</pre>
И, наконец, выполняем объединение:
<pre>
data = rfn.join_by('ngc', data, nebula_distance, jointype='leftouter', usemask=False, defaults={'dist': 0})
</pre>
Первый параметр - название поля, по которому объединяем массивы.
Затем - массивы данных. Порядок передачи важен, так как будем использовать leftouter join (смотри ниже).
Первым нужно передать массив, где содержатся основные данные, а затем массив с дополнительными данными, которые мы хотим добавить.
jointype - <a href="https://ru.wikipedia.org/wiki/Join_(SQL)#.D0.92.D0.B8.D0.B4.D1.8B_.D0.BE.D0.BF.D0.B5.D1.80.D0.B0.D1.82.D0.BE.D1.80.D0.B0_JOIN">тип объединения</a>.
Используем left outer join. Из первого массива берутся все записи и для каждой ищется соответствие во втором.
Если какой-то записи
нет соответствующей записи во второй таблице, то вместо данных из второй таблицы будут записаны заданные значения по умолчанию.
<b>usemask</b> - если передать True или не передавать, то будет возвращен
<a href="http://docs.scipy.org/doc/numpy/reference/maskedarray.html">MaskedArray</a> - массив, который может содержать
отсутствующие (аналог NULL в SQL) значения. Мы передадим False - получить обычный массив.
<b>defaults</b> - значения по умолчанию. Можно указать, какие значения записать в результат, если строке из первой
таблицы нет соответствия во второй таблице.

=====================[Добавление полей]===========================

Теперь нужно обработать данные: перевести единицы измерения, вычислить координаты объектов и т.п.
Для хранения новых данных нужно добавить к нашему массиву данных (в numpy он называется
<a href="http://docs.scipy.org/doc/numpy/user/basics.rec.html">structured array</a>) новые поля.
Сначала создадим данные для инициализации новой колонки. Так как данные мы будем расчитывать позже,
создадим просто массив нулей. Создается он при помощи функции zeros. Например, для значений float:
<pre>
fill_with_zeros = np.zeros(data.size)
</pre>
Для добавления полей используем функцию append_fields:
<pre>
data = rfn.append_fields(data, ['x', 'y', 'z'], data=[fill_with_zeros, fill_with_zeros, fill_with_zeros], usemask=False)
</pre>
Здесь все просто: передается массив, к которому нужно добавить поля,
названия новых полей и данные для новых полей. Параметр usemask как и в предыдущей функции говорит, что
нужно вернуть обычный, а не <a href="http://docs.scipy.org/doc/numpy/reference/maskedarray.html">MaskedArray</a>.
Значения из массива fill_with_zeros будут скопированы в новые поля массива data, поэтому один
массив можно передать для инициализации нескольких добавляемых колонок.

==============[Преобразование единиц измерения]===================

Для некоторых величин перед отображением нужно преобразовать единицы измерения.
Например, углы часто в данных указаны в градусах. Нам нужно преобразовать их в радианы.
Делается это вызовом функции radians:
<pre>
data["glong"] = np.radians(data["glong"])
</pre>
Расстояния часто даны в
<a href="https://ru.wikipedia.org/wiki/%D0%9F%D0%B0%D1%80%D1%81%D0%B5%D0%BA">парсеках</a>.
Лично мне проще, когда расстояния указаны в световых годах. Можно представить огромные пространства,
через которые свет летит тысячи лет. Для перевода в световые года можно просто воспользоваться
константой отношения парсека к световому году:
<pre>
def parsec_to_lightyear(dist):
    LIGHT_YEARS_IN_PARSEC = 3.2615638
    return dist * LIGHT_YEARS_IN_PARSEC
</pre>
Т.е. чтобы быстро и примерно перевести в уме можно умножить расстояние в парсеках на 3.
Иногда расстояния до объекта не указано, но указан
<a href="https://ru.wikipedia.org/wiki/%D0%9F%D0%B0%D1%80%D0%B0%D0%BB%D0%BB%D0%B0%D0%BA%D1%81">параллакс</a>
в миллисекундах.
В этом случае для определения расстояния до звезды используем то, что
расстояние в парсеках обратно пропорционально параллаксу в секундах. Таким образом,
для нахождения расстояния до объекта в световых годах по известному параллаксу в миллисекундах
используем такую простую функцию:
<pre>
def parallax_millisecond_to_light_year(p):
    d = 1 / (p * consts.milli)
    return parsec_to_lightyear(d)
</pre>
!!!!!! может быть дописать про то, как выводится парсек из параллакса
!!!!!! https://en.wikipedia.org/wiki/Small-angle_approximation


=================[Преобразование координат]=======================

Для отображения объектов в пространстве удобно использовать каталоги, в которых есть координаты объектов в
<a href="https://ru.wikipedia.org/wiki/%D0%93%D0%B0%D0%BB%D0%B0%D0%BA%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B0%D1%8F_%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B0_%D0%BA%D0%BE%D0%BE%D1%80%D0%B4%D0%B8%D0%BD%D0%B0%D1%82">
галактической системе кооординат
</a>.
Это сферическая система координат, где центром является наше Солнце.
Насколько я понял, в matplotlib пока не реализовано отображение трехмерного графика заданного в сферической системе координат.
Поэтому нам для отображения в пространстве нужно перейти от
<a href="https://ru.wikipedia.org/wiki/%D0%A1%D1%84%D0%B5%D1%80%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B0%D1%8F_%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B0_%D0%BA%D0%BE%D0%BE%D1%80%D0%B4%D0%B8%D0%BD%D0%B0%D1%82">сферической</a>
к <a href="https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D1%8F%D0%BC%D0%BE%D1%83%D0%B3%D0%BE%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F_%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B0_%D0%BA%D0%BE%D0%BE%D1%80%D0%B4%D0%B8%D0%BD%D0%B0%D1%82">декартовой</a>
системе координат. Для перевода используем формулы перехода от сферической системы координат к декартовой.
Единственное, широта у нас отсчитывается не от направления на зенит, а от плоскости галактики.
Значит вместо угла theta нужно подставлять pi/2 - theta. Так как sin(pi/2 - theta) = cos(theta) и cos(pi/2 - theta) = sin(theta),
то получаются такие формулы (где glat - галактическая широта, а glong - галактическая долгота):
<pre>
x = dist * np.cos(glat) * np.cos(glong)
y = dist * np.cos(glat) * np.sin(glong)
z = dist * np.sin(glat)
</pre>

===================[Отображение графика]==========================

==================================================================


======================[Наблюдение (результаты)]===================

=============================[Звезды]=============================

Первое, что видит человек глядя на ясное ночное небо это звезды.
В первую очередь мне были интересны звезды видимые невооруженным глазом.
Понятно, что в телескоп можно увидеть очень далекие объекты.
Но где находятся и как расположены звезды, которые видны без специальных
приборов и на которые люди смотрят уже тысячи лет?

===видимые звезды <6 величины
Яркость космических объектов измеряется в
<a href="https://ru.wikipedia.org/wiki/%D0%97%D0%B2%D1%91%D0%B7%D0%B4%D0%BD%D0%B0%D1%8F_%D0%B2%D0%B5%D0%BB%D0%B8%D1%87%D0%B8%D0%BD%D0%B0">звездных величинах</a>.
Чем меньше звездная величина объекта, тем он ярче.
Невооруженным глазом видны звезды +7 и меньше звездной величины.
Выберем такие звезды из каталога в
<a href="http://vizier.u-strasbg.fr/viz-bin/VizieR">VizieR</a>.

===1000 ярких звезд
Сначала посмотрим 1000 самых ярких звезд.  Отобразим их при помощи графика scatter.
Звездную величину звезды будем отображать при помощи цвета, задав параметр cmap (color map).
Пусть слабые звездочки будут синими, посильнее белыми, а самые яркие оранжевыми и красными.
Увидим такую картинку:
(((1000_brightest_stars.png)))
Видно, что видимые звезды окружают Солнце плотным роем радиусом около 200 световых лет.
Также вблизи Солнца, в пределах 100 световых лет видно много светлых точек - ярких звезд.
Дальше двухсот световых лет выдимые звезды становятся реже и в основном это слабые звездочки.
Но и там тоже есть светлые точки - яркие звезды.

===видно, что звезды лежат в плоскости галактики
Если повернуть график и посмотреть на солнце со стороны плоскости галактики
(можно убрать фильтр на 1000 звезд и отобразить все звезды) видно, что звезд в направлении
плоскости больше, чем вверх или вниз от диска галактики.
(((galaxy_disk.png)))
Заметно, что Солнце находится примерно посередине диска.

===толщина галактического диска
Также видно, что дальше 1000 световых лет вверх и вниз от плоскости галактики звезд почти нет, видны только отдельные звездочки.
Хотя у нас отображены только видимые невооруженным глазом звезды можно по этим данным примерно сказать, что толщина диска галактики
в том месте где сейчас находится Солнце составляет около 2000 световых лет.

===гистограмма звезд
Построим
<a href="https://ru.wikipedia.org/wiki/%D0%93%D0%B8%D1%81%D1%82%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B0">гистограмму</a>
показывающую сколько видимых звезд на каком расстоянии от нас находятся.
Делается это в matplotlib очень просто, всего одним вызовом функции:
<pre>
plt.hist(data['dist'], bins=100)
</pre>
Увидим такой график:
(((star_histogram.png)))


===беззвездное небо если подняться над диском галактики

===самые далекие видимые звезды

===30 самых ярких звезд
(((30_brightest_stars.png)))


===Расстояния до звезд не точные

===далекие яркие звезды: deneb, бетельгейзе, rigel, alnilam

===глазом мы видим только очень близкую часть космоса

===созвездия
(((ursa_major.png)))
(((ursa_major_view.png)))

(((orion.png)))
(((orion_view.png)))
Все яркие звезды созвездия находятся довольно далеко от Земли.



=========================[Шаровые скопления]======================
===описание шаровых скоплений
Следующий вид объектов, с которым сталкивается начинающий любитель астрономии на небе -
это <a href="https://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D1%80%D0%BE%D0%B2%D0%BE%D0%B5_%D0%B7%D0%B2%D1%91%D0%B7%D0%B4%D0%BD%D0%BE%D0%B5_%D1%81%D0%BA%D0%BE%D0%BF%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5">
шаровые звездные скопления</a>. Они достаточно яркие, их легко найти на небе,
<a href="https://ru.wikipedia.org/wiki/%D0%9E%D0%BC%D0%B5%D0%B3%D0%B0_%D0%A6%D0%B5%D0%BD%D1%82%D0%B0%D0%B2%D1%80%D0%B0">некоторые</a>
даже видны невооруженным глазом. Вот, например, как выглядит в телескоп Большое скопление Геркулеса, M13:
(((m13_photo.png)))

===шаровые скопления scatter
Отобразим шаровые скопления нашей галактики:
(((globular_clusters_scatter.png)))
Чтобы картинка была нагляднее на ней отображено также Солнце,
примерная круговая орбита солнца вокруг галактического центра и край диска галактики.

===видны на больших расстояниях
Видно, что все шаровые скопления расположены намного дальше от нас, чем видимые звезды.
Ближайшее известное скопление M4 расположено на расстоянии ~7200 световых лет от нас.
Остальные скопления расположены еще дальше.
Шаровые скопления содержат сотни тысяч звезд и поэтому видны на таких больших расстояниях.

===шаровые скопления не в плоскости галактики
Если посмотреть на картинку со стороны плоскости галактики, то видно, что многие скопления
расположены далеко от центра галактики:
(((globular_clusters_scatter_side.png)))
Орбиты многих скоплений сильно отклонены от плоскости галактики.
Так как звезды в скоплении расположены очень близко друг к другу и сильно связаны гравитацией,
скопление может вращаясь по орбите много раз проходить сквозь галактический диск не разрушаясь.

===определение центра галактики
Интересно, что с помощью шаровых скоплений было впервые приблизительно найдено расположение
<a href="https://ru.wikipedia.org/wiki/%D0%93%D0%B0%D0%BB%D0%B0%D0%BA%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9_%D1%86%D0%B5%D0%BD%D1%82%D1%80">центра нашей галактики</a>.
Так как в галактическом диске содержится большое количество пыли, то непосредственно увидеть
центр галактики в оптическом диапазоне не удавалось. Для примерного определения расположения центра ученый
<a href="https://ru.wikipedia.org/wiki/%D0%A8%D0%B5%D0%BF%D0%BB%D0%B8,_%D0%A5%D0%B0%D1%80%D0%BB%D0%BE%D1%83">Харлоу Шепли</a>
исследовал распределение шаровых скоплений на небе. Так как все скопления вращаются вокруг центра галактики,
то со стороны центра их должно быть больше всего. Таким образом удалось достаточно точно установить расположение центра Млечного Пути.


===область 1000 ly вокруг солнца

===шаровые скопления мессье
(((globular_clusters_messier.png)))


=======================[Рассеянные скопления]=====================

[Туманности]

[Галактики]

==================================================================

[Заключение]

